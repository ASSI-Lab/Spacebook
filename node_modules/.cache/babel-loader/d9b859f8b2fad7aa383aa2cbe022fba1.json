{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.1.3): util/scrollBar.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\nimport SelectorEngine from '../dom/selector-engine';\nimport Manipulator from '../dom/manipulator';\nimport { isElement } from './index';\nvar SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\nvar SELECTOR_STICKY_CONTENT = '.sticky-top';\n\nvar ScrollBarHelper = /*#__PURE__*/function () {\n  function ScrollBarHelper() {\n    _classCallCheck(this, ScrollBarHelper);\n\n    this._element = document.body;\n  }\n\n  _createClass(ScrollBarHelper, [{\n    key: \"getWidth\",\n    value: function getWidth() {\n      // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\n      var documentWidth = document.documentElement.clientWidth;\n      return Math.abs(window.innerWidth - documentWidth);\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var width = this.getWidth();\n\n      this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width\n\n\n      this._setElementAttributes(this._element, 'paddingRight', function (calculatedValue) {\n        return calculatedValue + width;\n      }); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\n\n\n      this._setElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight', function (calculatedValue) {\n        return calculatedValue + width;\n      });\n\n      this._setElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight', function (calculatedValue) {\n        return calculatedValue - width;\n      });\n    }\n  }, {\n    key: \"_disableOverFlow\",\n    value: function _disableOverFlow() {\n      this._saveInitialAttribute(this._element, 'overflow');\n\n      this._element.style.overflow = 'hidden';\n    }\n  }, {\n    key: \"_setElementAttributes\",\n    value: function _setElementAttributes(selector, styleProp, callback) {\n      var _this = this;\n\n      var scrollbarWidth = this.getWidth();\n\n      var manipulationCallBack = function manipulationCallBack(element) {\n        if (element !== _this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {\n          return;\n        }\n\n        _this._saveInitialAttribute(element, styleProp);\n\n        var calculatedValue = window.getComputedStyle(element)[styleProp];\n        element.style[styleProp] = \"\".concat(callback(Number.parseFloat(calculatedValue)), \"px\");\n      };\n\n      this._applyManipulationCallback(selector, manipulationCallBack);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._resetElementAttributes(this._element, 'overflow');\n\n      this._resetElementAttributes(this._element, 'paddingRight');\n\n      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight');\n\n      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight');\n    }\n  }, {\n    key: \"_saveInitialAttribute\",\n    value: function _saveInitialAttribute(element, styleProp) {\n      var actualValue = element.style[styleProp];\n\n      if (actualValue) {\n        Manipulator.setDataAttribute(element, styleProp, actualValue);\n      }\n    }\n  }, {\n    key: \"_resetElementAttributes\",\n    value: function _resetElementAttributes(selector, styleProp) {\n      var manipulationCallBack = function manipulationCallBack(element) {\n        var value = Manipulator.getDataAttribute(element, styleProp);\n\n        if (typeof value === 'undefined') {\n          element.style.removeProperty(styleProp);\n        } else {\n          Manipulator.removeDataAttribute(element, styleProp);\n          element.style[styleProp] = value;\n        }\n      };\n\n      this._applyManipulationCallback(selector, manipulationCallBack);\n    }\n  }, {\n    key: \"_applyManipulationCallback\",\n    value: function _applyManipulationCallback(selector, callBack) {\n      if (isElement(selector)) {\n        callBack(selector);\n      } else {\n        SelectorEngine.find(selector, this._element).forEach(callBack);\n      }\n    }\n  }, {\n    key: \"isOverflowing\",\n    value: function isOverflowing() {\n      return this.getWidth() > 0;\n    }\n  }]);\n\n  return ScrollBarHelper;\n}();\n\nexport default ScrollBarHelper;","map":null,"metadata":{},"sourceType":"module"}